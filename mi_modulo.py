# -*- coding: utf-8 -*-
"""Mi_Modulo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mYaiCTya_Hs4alV6ORwBEYbWJI3Iwrhy
"""

import matplotlib.pyplot as plt
import numpy as np
import statsmodels.api as sm
from scipy.stats import norm

class mi_clase:

  class Regresion:
      resumen = {}

      def __init__(self,y,x):
        """ Recibe los datos pretatados: y es un vector (variable respuesta o endógena), x es vector o matriz (variable(s) predictora(s) o exógena(s).)"""
        self.datos_x = x
        self.datos_y = y
        self.X = sm.add_constant(self.datos_x) # Crea la matriz para los modelos de regresión.
        
  class RegresionLineal(Regresion):
    """ Implementa Regresión lineal"""
    """ Si la dimensión de x es 1 (vector), el modelo es simple. Si la dimensión es 2 o más (más de una variable predictora), el modelo es múltiple. """
    """ Ingresa y vector respuesta (endógena), x: vector o matriz de predictoras (exógenas)"""
    """ Métodos:
      - estimar_modelo_lineal: modelo de regresión lineal, parámetros, predichos y summary.
        Devuelve resumen (diccionario).
      - imprimir_modelo: print summary
      - grafica_scatter
      - grafica_qqplot
      - grafica_homoceda
      - estudio_supuestos: los 3 anteriores y test no paramétrico de homoceda.
    """

    resumen = {}

    

    def estimar_modelo_lineal(self):
      """ Calcular los coeficientes de la regresión lineal (tanto sea simple como múltiple)
        - Calcula: betas y sus p-valores, predichos, residuos y summary
      """
      y = self.datos_y
      X = self.X

      # se define el modelo de regresión lineal
      modelo = sm.OLS(y, X)

      # se estiman los parámetros a partir del ajuste lineal
      resultado = modelo.fit()
      betas = resultado.params
      p_values_betas = resultado.pvalues
      # Crear la recta de mejor ajuste
      predichos = resultado.fittedvalues
      residuos = resultado.resid
      summary = resultado.summary()
      resumen = {'resultado':resultado,
              'betas':betas,
              'p_valores_betas':p_values_betas,
              'predichos':predichos,
              'residuos':residuos,
              'summary':summary}
      return resumen

    def imprimir_resumen(self):
      """ Imprime resumen del método OLS.fit"""

      print(self.estimar_modelo_lineal()['summary'])


    def grafica_scatter(self):
      """ Gráfica scatter de datos y recta y_estim"""
      """ Sirve para supuesto de linealidad"""

      x = self.datos_x
      y = self.datos_y

      predichos = self.estimar_modelo_lineal()['predichos']

      plt.scatter(x, y, label="Datos")
      plt.plot(x, predichos, label="Recta de Mejor Ajuste", linestyle="--", color="red")
      plt.title('Gráfico de Dispersión con Recta de Mejor Ajuste')
      plt.xlabel("X")
      plt.ylabel("Y")
      plt.legend()
      plt.show()

    def grafica_qqplot(self):
      """ Gráfica qqplot para normalidad de errores (estandarizado)"""
      residuos = self.estimar_modelo_lineal()['residuos']

      sm.qqplot(residuos, line='s')
      plt.title('QQ Plot (Datos estandarizados)')
      plt.show()

    def grafica_homoceda(self):
      """ Gráfica residuos/y_estim para varianza constante (homocedasticidad)"""
      predichos = self.estimar_modelo_lineal().get('predichos')
      residuos = self.estimar_modelo_lineal().get('residuos')
      plt.scatter(predichos, residuos, label="Residuos", color="red")
      plt.vlines(predichos,np.zeros(len(predichos)),residuos)
      plt.axhline(y=0, color='b', linestyle='--')  # Línea horizontal en y=0 para facilitar la visualización de los residuos
      plt.title('Gráfico de Residuos vs. Valores Predichos')
      plt.xlabel("Y predicho")
      plt.ylabel("Residuo de ajuste")
      plt.legend();

    def estudio_supuestos(self):
      """ Estudio gráfico de 3 supuestos (lin, norm, varinza cte)
          y test no parámetrico de homocedasticidad (bp)"""

      self.grafica_scatter()
      self.grafica_qqplot()
      self.grafica_homoceda()

      # media de los residuos
      residuos = self.estimar_modelo_lineal()['residuos']

      print("Media de los residuos:", np.mean(residuos))

      from statsmodels.stats.diagnostic import het_breuschpagan, het_white
      X = self.X
      bp_test = het_breuschpagan(residuos, X)
      bp_value = bp_test[1]
      print("Valor p Homocedasticidad:", bp_value)

    def prediccion(self, x_predic, alfa = None, conf = None):
      """ Predicción puntual, IC para predicción (valores reales), IPredicción (valor por venir): más amplio que IC
        alfa = 0.05 por defecto
        conf = None por defecto (da estimación puntual); False da intervalo de confianza; True da int de predicc; 'Both' da ambos intervalos.
        """
      if alfa is None:
        alfa = 0.05
      #if conf is None:
      #  conf = False

      X_prediccion = sm.add_constant(np.array([[1, x_predic]]))
      modelo = self.estimar_modelo_lineal()['resultado']
      y_predic = modelo.predict(X_prediccion)
      intervalo_confianza = modelo.get_prediction(X_prediccion).conf_int(alpha=alfa)
      print(f"Valor medio de Y para un valor estimado de x = {x_predic}: {y_predic[0]}")

      if conf == False or conf == 'Both':
        intervalo_confianza = modelo.get_prediction(X_prediccion).conf_int(alpha=alfa)
        print(f"Intervalo de confianza del 95% de la media de y para x = {x_predic}: {intervalo_confianza[0]}")

      if conf == True or conf == 'Both':
        intervalo_pred = modelo.get_prediction(X_prediccion).conf_int(obs = True, alpha=alfa)
        print(f"Intervalo de predicción del 95% de y para x = {x_predic}: {intervalo_pred[0]}")

""" Clase GeneradoraDeDatos

"""
  class GeneradoraDeDatos:
    def __init__(self,n):
      self.n = n

    def generar_datos_dist_norm(self,media,desvio):
      y_norm = np.random.normal(media, desvio, self.n)
      return y_norm

    def generar_datos_dist_BS(self):
      y_BS=0
      for j in range(5):
        y_BS += 0.1*(np.random.normal(0.5*j-1,0.1,self.n))
      y_BS += 0.5*np.random.normal(0,1,self.n)
      return y_BS


""" Clase ResumenGrafico

"""
  class ResumenGrafico:
  def __init__(self, datos):
    self.datos = np.array(datos)
    #self.x = np.array(x)

  def genera_histograma(self,h):

    bins = np.arange(min(self.datos),max(self.datos),h)
    if max(self.datos) > bins[-1]:
      bins = np.append(bins, bins[-1]+h)
    m = len(bins)

    histo = np.zeros(m-1)
    for dato in self.datos:
      for i in range(m-1):
        if dato == bins[0]:
          histo[0] +=1
          break
        elif bins[i] < dato <= bins[i+1]:
          histo[i] +=1
          break
    histo /=  (len(self.datos) * h)
    return bins, histo


  def evalua_histograma(self, h, x):
    ## Completar
    bins, histo = self.genera_histograma(h)

    estim_hist = np.zeros(len(x))
    for j in range(len(x)):
      if x[j] == min(self.datos):
        estim_hist[j] == histo[0]
      else:
        for i in range(len(bins)-1):
          if bins[i] < x[j] <= bins[i+1]:
            estim_hist[j] = histo[i]
            break

    return estim_hist

############### Densidades teóricas

  def pdf_norm(self,x,media,desvio):
  # Densidad teórica normal
    pdf_norm = norm.pdf(x,media,desvio)
    return pdf_norm

  def densidad_exponencial(self,x,b):
    d = []
    for i in range(len(x)):
      if x[i] < 0:
        d.append(0)
      else:
        d.append((1/b)*np.exp(-x[i]/b))
    return d

################ Densidades experimentales

  def caracteristica(self,int_min,int_max):
  # Función característica del intervalo (int_min, int_max]: abierto, cerrado
    caract = []
    for j in range(len(self)):
      caract.append(int_min < self[j]  <= int_max)
    return caract

  def kernel_uniforme(self):
    # Kernel uniforme
    valor_kernel_uniforme = sum(ResumenGrafico.caracteristica(self,-1,1)) / 2
    return valor_kernel_uniforme

  def kernel_gaussiano(self):
    # Kernel gaussiano estándar
    valor_kernel_gaussiano = sum((1/(np.sqrt(2*np.pi))) * (np.exp(-0.5 * self**2)))
    return valor_kernel_gaussiano

  def kernel_cuadratico(self):
    # Kernel Cuadrático de Epanechnikov
    valor_kernel_cuadratico = (3/4) * sum((1-self**2) * ResumenGrafico.caracteristica(self,-1,1))
    return valor_kernel_cuadratico

  def kernel_triangular(self):
    # Kernel Triangular
    valor_kernel_triangular = sum((1+self) * ResumenGrafico.caracteristica(self,-1,0) + (1-self) * ResumenGrafico.caracteristica(self,0,1))
    return valor_kernel_triangular


  def densidad_nucleo(self,x,h,kernel):
    # x: Puntos en los que se evaluará la densidad
    # data: Datos
    # h: Ancho de la ventana (bandwidth)

    frec_vector = np.zeros(len(x))
    density = np.zeros(len(x))

    for i in range(len(x)):
      data_std = (self.datos - x[i])/h
      if kernel =='uniforme':
        frec_vector[i] = ResumenGrafico.kernel_uniforme(data_std)
      elif kernel == 'gaussiano':
        frec_vector[i] = ResumenGrafico.kernel_gaussiano(data_std)
      elif kernel == 'cuadratico':
        frec_vector[i] = ResumenGrafico.kernel_cuadratico(data_std)
      elif kernel =='triangular':
        frec_vector[i]= ResumenGrafico.kernel_triangular(data_std)
      else:
        frec_vector[i] = data_std

    density = frec_vector/(len(self.datos)*h)

    return density

# @title
import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import norm

class GeneradoraDeDatos:
  def __init__(self,n):
    self.n = n

  def generar_datos_dist_norm(self,media,desvio):
    y_norm = np.random.normal(media, desvio, self.n)
    return y_norm

  def generar_datos_dist_BS(self):
    y_BS=0
    for j in range(5):
      y_BS += 0.1*(np.random.normal(0.5*j-1,0.1,self.n))
    y_BS += 0.5*np.random.normal(0,1,self.n)
    return y_BS

# @title
import matplotlib.pyplot as plt

class ResumenGrafico:
  def __init__(self, datos):
    self.datos = np.array(datos)
    #self.x = np.array(x)

  def genera_histograma(self,h):

    bins = np.arange(min(self.datos),max(self.datos),h)
    if max(self.datos) > bins[-1]:
      bins = np.append(bins, bins[-1]+h)
    m = len(bins)

    histo = np.zeros(m-1)
    for dato in self.datos:
      for i in range(m-1):
        if dato == bins[0]:
          histo[0] +=1
          break
        elif bins[i] < dato <= bins[i+1]:
          histo[i] +=1
          break
    histo /=  (len(self.datos) * h)
    return bins, histo


  def evalua_histograma(self, h, x):
    ## Completar
    bins, histo = self.genera_histograma(h)

    estim_hist = np.zeros(len(x))
    for j in range(len(x)):
      if x[j] == min(self.datos):
        estim_hist[j] == histo[0]
      else:
        for i in range(len(bins)-1):
          if bins[i] < x[j] <= bins[i+1]:
            estim_hist[j] = histo[i]
            break

    return estim_hist

############### Densidades teóricas

  def pdf_norm(self,x,media,desvio):
  # Densidad teórica normal
    pdf_norm = norm.pdf(x,media,desvio)
    return pdf_norm

  def densidad_exponencial(self,x,b):
    d = []
    for i in range(len(x)):
      if x[i] < 0:
        d.append(0)
      else:
        d.append((1/b)*np.exp(-x[i]/b))
    return d

################ Densidades experimentales

  def caracteristica(self,int_min,int_max):
  # Función característica del intervalo (int_min, int_max]: abierto, cerrado
    caract = []
    for j in range(len(self)):
      caract.append(int_min < self[j]  <= int_max)
    return caract

  def kernel_uniforme(self):
    # Kernel uniforme
    valor_kernel_uniforme = sum(ResumenGrafico.caracteristica(self,-1,1)) / 2
    return valor_kernel_uniforme

  def kernel_gaussiano(self):
    # Kernel gaussiano estándar
    valor_kernel_gaussiano = sum((1/(np.sqrt(2*np.pi))) * (np.exp(-0.5 * self**2)))
    return valor_kernel_gaussiano

  def kernel_cuadratico(self):
    # Kernel Cuadrático de Epanechnikov
    valor_kernel_cuadratico = (3/4) * sum((1-self**2) * ResumenGrafico.caracteristica(self,-1,1))
    return valor_kernel_cuadratico

  def kernel_triangular(self):
    # Kernel Triangular
    valor_kernel_triangular = sum((1+self) * ResumenGrafico.caracteristica(self,-1,0) + (1-self) * ResumenGrafico.caracteristica(self,0,1))
    return valor_kernel_triangular


  def densidad_nucleo(self,x,h,kernel):
    # x: Puntos en los que se evaluará la densidad
    # data: Datos
    # h: Ancho de la ventana (bandwidth)

    frec_vector = np.zeros(len(x))
    density = np.zeros(len(x))

    for i in range(len(x)):
      data_std = (self.datos - x[i])/h
      if kernel =='uniforme':
        frec_vector[i] = ResumenGrafico.kernel_uniforme(data_std)
      elif kernel == 'gaussiano':
        frec_vector[i] = ResumenGrafico.kernel_gaussiano(data_std)
      elif kernel == 'cuadratico':
        frec_vector[i] = ResumenGrafico.kernel_cuadratico(data_std)
      elif kernel =='triangular':
        frec_vector[i]= ResumenGrafico.kernel_triangular(data_std)
      else:
        frec_vector[i] = data_std

    density = frec_vector/(len(self.datos)*h)

    return density

class RegresionLogistica:
    """ Implementa Regresión logistica"""
    """ Si la dimensión de x es 1 (vector), el modelo es simple. Si la dimensión es 2 o más (más de una variable predictora), el modelo es múltiple. """
    """ Ingresa y vector respuesta (endógena), x: vector o matriz de predictoras (exógenas)"""
    """ Métodos:
      - estimar_modelo_logit: modelo de regresión logit, parámetros, predichos y summary.
        Devuelve resumen (diccionario).
      - imprimir_modelo: print summary
      - grafica_scatter
      - grafica_qqplot
      - grafica_homoceda
      - estudio_supuestos: los 3 anteriores y test no paramétrico de homoceda.
    """

    resumen = {}

    def __init__(self,y,x):
      """ Recibe los datos pretatados: y es un vector (variable respuesta o endógena), x es vector o matriz (variable(s) predictora(s) o exógena(s).)"""
      self.datos_x = x
      self.datos_y = y
      self.X = sm.add_constant(self.datos_x) # Crea la matriz para los modelos de regresión.


    def estimar_modelo_logit(self):
      """ Calcular los coeficientes de la regresión lineal (tanto sea simple como múltiple)
        - Calcula: betas y sus p-valores, predichos, residuos y summary
      """
      y = self.datos_y
      X = self.X

      # se define el modelo de regresión logistico
      modelo = sm.Logit(y, X)

      # se estiman los parámetros a partir del ajuste lineal
      resultado = modelo.fit()
      betas = resultado.params
      p_values_betas = resultado.pvalues
      # Crear la recta de mejor ajuste
      predichos = resultado.fittedvalues
      #residuos = resultado.resid
      summary = resultado.summary()
      resumen = {'resultado':resultado,
              'betas':betas,
              'p_valores_betas':p_values_betas,
              'predichos':predichos,
              #'residuos':residuos,
              'summary':summary}
      return resumen

    def imprimir_resumen(self):
      """ Imprime resumen del método Logit.fit"""

      print(self.estimar_modelo_logit()['summary'])


    def grafica_scatter(self):
      """ Gráfica scatter de datos y recta y_estim"""
      """ Sirve para supuesto de linealidad"""

      x = self.datos_x
      y = self.datos_y

      predichos = self.estimar_modelo_logit()['predichos']

      plt.scatter(x, y, label="Datos")
      plt.plot(x, predichos, label="Recta de Mejor Ajuste", linestyle="--", color="red")
      plt.title('Gráfico de Dispersión con Recta de Mejor Ajuste')
      plt.xlabel("X")
      plt.ylabel("Y")
      plt.legend()
      plt.show()

    '''def grafica_qqplot(self):
      """ Gráfica qqplot para normalidad de errores (estandarizado)"""
      residuos = self.estimar_modelo_lineal()['residuos']

      sm.qqplot(residuos, line='s')
      plt.title('QQ Plot (Datos estandarizados)')
      plt.show()'''

    '''def grafica_homoceda(self):
      """ Gráfica residuos/y_estim para varianza constante (homocedasticidad)"""
      predichos = self.estimar_modelo_lineal().get('predichos')
      residuos = self.estimar_modelo_lineal().get('residuos')
      plt.scatter(predichos, residuos, label="Residuos", color="red")
      plt.vlines(predichos,np.zeros(len(predichos)),residuos)
      plt.axhline(y=0, color='b', linestyle='--')  # Línea horizontal en y=0 para facilitar la visualización de los residuos
      plt.title('Gráfico de Residuos vs. Valores Predichos')
      plt.xlabel("Y predicho")
      plt.ylabel("Residuo de ajuste")
      plt.legend();'''

    '''def estudio_supuestos(self):
      """ Estudio gráfico de 3 supuestos (lin, norm, varinza cte)
          y test no parámetrico de homocedasticidad (bp)"""

      self.grafica_scatter()
      self.grafica_qqplot()
      self.grafica_homoceda()

      # media de los residuos
      residuos = self.estimar_modelo_lineal()['residuos']

      print("Media de los residuos:", np.mean(residuos))

      from statsmodels.stats.diagnostic import het_breuschpagan, het_white
      X = self.X
      bp_test = het_breuschpagan(residuos, X)
      bp_value = bp_test[1]
      print("Valor p Homocedasticidad:", bp_value)'''

    def prediccion(self, x_predic, alfa = None, conf = None):
      """ Predicción puntual, IC para predicción (valores reales), IPredicción (valor por venir): más amplio que IC
        alfa = 0.05 por defecto
        conf = None por defecto (da estimación puntual); False da intervalo de confianza; True da int de predicc; 'Both' da ambos intervalos.
      """
      if alfa is None:
        alfa = 0.05
      #if conf is None:
      #  conf = False

      X_prediccion = sm.add_constant(np.array([[1, x_predic]]))
      modelo = self.estimar_modelo_logit()['resultado']
      y_predic = modelo.predict(X_prediccion)
      intervalo_confianza = modelo.get_prediction(X_prediccion).conf_int(alpha=alfa)
      print(f"Valor medio de Y para un valor estimado de x = {x_predic}: {y_predic[0]}")

      if conf == False or conf == 'Both':
        intervalo_confianza = modelo.get_prediction(X_prediccion).conf_int(alpha=alfa)
        print(f"Intervalo de confianza del 95% de y para x = {x_predic}: {intervalo_confianza[0]}")

      if conf == True or conf == 'Both':
        intervalo_pred = modelo.get_prediction(X_prediccion).conf_int(obs = True, alpha=alfa)
        print(f"Intervalo de predicción del 95% de y para x = {x_predic}: {intervalo_pred[0]}")